# Supabase Setup for Phonics Fun App

This guide will walk you through setting up a Supabase project and database for use with the Phonics Fun application.

## 1. Create a New Supabase Project

1.  Go to [Supabase](https://supabase.com/) and sign in or create an account.
2.  Click on **New project**.
3.  Choose an organization (or create one).
4.  Enter a **Project name** (e.g., "PhonicsFunDB").
5.  Enter a strong **Database Password**. Make sure to save this password securely.
6.  Choose a **Region** that is geographically close to your users.
7.  Select the **Free plan** (or a paid plan if you anticipate higher usage).
8.  Click **Create new project**. Wait for your project to be provisioned.

## 2. Get Project URL and Anon Key

Once your project is ready:

1.  From the Supabase dashboard, navigate to your project.
2.  In the left sidebar, click on **Project Settings** (the gear icon).
3.  Select the **API** tab.
4.  You will find your **Project URL** and your **Project API keys**.
5.  Copy the **URL** (this will be your `NEXT_PUBLIC_SUPABASE_URL`).
6.  Under **Project API keys**, copy the `anon` **public** key (this will be your `NEXT_PUBLIC_SUPABASE_ANON_KEY`).

## 3. Set Up Environment Variables

Create or update your `.env.local` file in the root of your Next.js project with the Supabase credentials:

```env
NEXT_PUBLIC_SUPABASE_URL="YOUR_SUPABASE_PROJECT_URL"
NEXT_PUBLIC_SUPABASE_ANON_KEY="YOUR_SUPABASE_ANON_PUBLIC_KEY"

# Existing variables (ensure these are still present)
GOOGLE_CLIENT_ID="YOUR_GOOGLE_CLIENT_ID"
GOOGLE_CLIENT_SECRET="YOUR_GOOGLE_CLIENT_SECRET"
NEXTAUTH_SECRET="YOUR_NEXTAUTH_SECRET"
# NEXTAUTH_URL="http://localhost:3000" # Or your production URL
```

Replace `"YOUR_SUPABASE_PROJECT_URL"` and `"YOUR_SUPABASE_ANON_PUBLIC_KEY"` with the actual values you copied.

## 4. Create Database Tables

You can use the Supabase SQL Editor or the Table Editor to create the required tables.

### Using SQL Editor

Navigate to the **SQL Editor** in the Supabase dashboard (icon that looks like a terminal window with `SQL` on it). Click **New query** and run the following SQL statements one by one or as a single script.

**Enable `uuid-ossp` extension (if not already enabled):**
This is usually enabled by default on new Supabase projects. If you encounter an error with `uuid_generate_v4()`, run this first.
```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
```

**Create `users` table:**
This table will store user information and link to `auth.users` (NextAuth users managed by Supabase Auth, if you choose to integrate deeply, or just your app's user concept).
```sql
CREATE TABLE public.users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    name TEXT,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL
);

-- Optional: Add a foreign key constraint if you are using Supabase Auth
-- and want to link `users.id` to `auth.users.id`.
-- This requires that the `id` in your `users` table matches the `id` from `auth.users`.
-- Make sure your NextAuth adapter/callbacks handle this correctly.
--
-- ALTER TABLE public.users
-- ADD CONSTRAINT fk_auth_users
-- FOREIGN KEY (id) REFERENCES auth.users(id)
-- ON DELETE CASCADE;
--
-- Note: For NextAuth integration, the user's ID from the provider (e.g., Google)
-- is typically stored. The `id` in `auth.users` is Supabase's own internal ID.
-- If you are managing users primarily through NextAuth and only using Supabase as a DB,
-- you might adjust this. The NextAuth callback will populate this table.
-- The `id` here will be the one generated by `uuid_generate_v4()` unless
-- you explicitly set it to match `session.user.id` from NextAuth (which comes from the provider).
-- For the proposed NextAuth callback logic, we will be creating a new UUID for our app's `users` table
-- and then linking it. Or, more simply, using the ID from the `auth.users` table if available.
-- The current NextAuth setup does not automatically use Supabase Auth.
-- We will use the `id` from the `session.user` object (provided by NextAuth after Google sign-in)
-- as the primary key for our `users` table. This requires adjusting the table definition if
-- the ID from Google is not a UUID, or handling the mapping in the callback.
--
-- For simplicity with the current NextAuth setup (not using Supabase Auth provider directly):
-- The `id` in this `users` table will be the one we insert from the NextAuth callback,
-- typically the `sub` or `id` from the OAuth provider.
-- Let's adjust the `users` table to make `id` a TEXT field if it's coming from Google directly
-- and is not a UUID. Or, we ensure the NextAuth callback generates/uses a UUID for this.
-- The NextAuth `profile.sub` (subject identifier) is a good candidate for `id`.
--
-- Given the NextAuth setup, it's better to make `users.id` a TEXT field if we directly use Google's `sub`.
-- However, the subtask asks for UUID. This means we'll need to generate a UUID in the callback
-- if the provider ID isn't one, or find a way to link it.
--
-- Re-definition for clarity with NextAuth (assuming we will handle ID mapping):
-- We'll let NextAuth provide the user ID. If it's from Supabase's own auth.users, it's a UUID.
-- If it's from Google, it's a string.
-- For now, let's assume we'll use the ID from `auth.users` if we were using Supabase Auth.
-- Since we are using NextAuth with Google provider, the `session.user.id` (from `token.sub`)
-- will be the Google user ID.
--
-- To align with the subtask's request for `users.id` to be UUID and reference `auth.users(id)`,
-- this implies a deeper integration with Supabase Auth than just using it as a DB.
-- If we are just using Supabase as a DB, the `users.id` can be its own UUID,
-- or it can be the Google User ID (text).
--
-- Let's assume `users.id` should be the ID from `auth.users` for RLS to work easily with `auth.uid()`.
-- This means the NextAuth callback needs to ensure the user exists in `auth.users`
-- (Supabase handles this if you use Supabase Auth for NextAuth).
-- If not using Supabase Auth directly with NextAuth, then `auth.uid()` won't work as expected
-- without custom JWT modification.
--
-- For this setup, we will make `users.id` a UUID. The NextAuth callback will need to
-- create a user in our `users` table, and this `id` will be our internal app-specific UUID.
-- We will NOT add the `REFERENCES auth.users(id)` for now to simplify, as that assumes
-- Supabase is also the Auth provider for NextAuth.
```

**Corrected `users` table SQL (without direct `auth.users` reference for simplicity with current NextAuth setup):**
```sql
CREATE TABLE public.users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), -- App-specific user ID
    email TEXT UNIQUE NOT NULL,
    name TEXT,
    auth_provider_id TEXT UNIQUE, -- Stores the Google User ID (from token.sub)
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL
);
```
*Self-correction: The subtask explicitly asks for `users.id` to reference `auth.users(id)`. This implies that Supabase itself is expected to handle the user entries in `auth.users` table, and our `users` table simply extends that. This is typically achieved by using `signInWithOAuth` from `@supabase/supabase-js` or by using the Supabase NextAuth adapter. Since we are manually managing the session and signIn callbacks, we need to be careful. If `next-auth` is configured with a Supabase adapter, it would handle this. Without it, `auth.uid()` in RLS policies for our custom tables might not work as seamlessly.*

*Given the constraints, the most straightforward interpretation is that `auth.users` is the source of truth for user IDs, and our `users` table links to it. This means the ID in our `users` table *must* be the same UUID that Supabase uses in `auth.users`. When a user signs in with Google via NextAuth, we'd need to:
1. Extract the Google user profile.
2. Upsert this user into Supabase `auth.users` (Supabase usually does this automatically if it handles the OAuth flow). If NextAuth handles the OAuth, we might need to manually add the user to `auth.users` or use a function for it. This is complex.
3. Then use that ID to create an entry in our `public.users` table.*

*A simpler approach for now, before deep adapter integration: The `users.id` will be a UUID we generate. RLS policies will be written assuming `auth.uid()` refers to the ID of the *authenticated user making the request*, which Supabase populates from the JWT. If our JWT (managed by NextAuth) is not recognized by Supabase PostgREST as a Supabase Auth JWT, `auth.uid()` might not work. We'll need to ensure NextAuth issues a JWT that Supabase can verify, or use a service role key for writes and carefully craft RLS for reads.*

*Let's proceed with the table structure as requested, assuming `auth.uid()` will be available and correctly populated in RLS policies. This might require later adjustments to NextAuth's JWT/session handling to ensure compatibility with Supabase RLS.*

**Final SQL for `users` table (as per subtask, assuming `auth.users` linkage):**
```sql
-- Ensure this runs after a user has signed up/logged in via Supabase Auth at least once,
-- or that the referenced auth.users entry is created by NextAuth adapter.
-- If not using a Supabase adapter for NextAuth, this FK might cause issues
-- as auth.users might not be populated as NextAuth expects.
-- For the purpose of this subtask, we'll define it as requested.
CREATE TABLE public.users (
    id UUID PRIMARY KEY, -- This ID must match the ID in auth.users
    email TEXT UNIQUE NOT NULL,
    name TEXT,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL
    -- CONSTRAINT fk_auth_users FOREIGN KEY(id) REFERENCES auth.users(id) ON DELETE CASCADE
);
-- Deferring the FK constraint fk_auth_users until NextAuth adapter setup is confirmed.
-- The current NextAuth setup does not use a Supabase adapter.
-- So, `auth.users(id)` won't be automatically populated by NextAuth.
-- We will create `id` as UUID without the FK for now.
-- The NextAuth callback will create a user in this table.
-- RLS policies will be based on this `id` matching `auth.uid()` - this requires the JWT token
-- that PostgREST sees to have a `sub` claim matching this `id`.
```
Revisiting the `users` table definition based on the subtask asking for `id` to reference `auth.users(id)`.
This is a core part of Supabase integration. If we don't use a Supabase adapter for NextAuth, then `auth.users` is not automatically populated when a user signs in via Google through NextAuth.
This means the `FOREIGN KEY (id) REFERENCES auth.users(id)` would fail unless we manually create a corresponding user in `auth.users`. This is not trivial.

A more practical approach for the current setup (NextAuth managing auth, Supabase as DB only):
1.  `users.id` is a `UUID PRIMARY KEY DEFAULT uuid_generate_v4()`. This is our internal application user ID.
2.  We add an `auth_provider_user_id` (TEXT, UNIQUE) column to store the actual Google User ID from NextAuth.
3.  RLS policies would then need to work with this `auth_provider_user_id` or we'd need a way to map `auth.uid()` (if it even gets populated from a NextAuth JWT) to our internal `users.id`.

However, the subtask is *specific* about `REFERENCES auth.users(id)`. This implies a setup where Supabase Auth is more deeply integrated.
If I proceed with that exact schema, the NextAuth callbacks will become very complex, potentially needing to use Supabase admin rights to insert into `auth.users` which is not recommended from client-side/Next.js backend.

Let me try to provide the SQL that matches the subtask as closely as possible, with comments on the implications for the NextAuth callbacks.

**SQL for `users` table (strict interpretation of subtask):**
```sql
-- This table assumes that the `id` column will be populated with the UUID
-- from the `auth.users` table. This typically means Supabase is handling
-- the authentication OR NextAuth is using a Supabase adapter that syncs users
-- to `auth.users`.
CREATE TABLE public.users (
    id UUID PRIMARY KEY, -- Must match auth.users.id
    email TEXT UNIQUE NOT NULL,
    name TEXT,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    CONSTRAINT fk_auth_user FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE
);
-- Note: For this to work, the NextAuth callbacks will need to:
-- 1. Get the user's profile from Google.
-- 2. Somehow ensure this user exists in `auth.users` table in Supabase.
--    This might involve a server-side call to a Supabase function or using admin rights if not using an adapter.
-- 3. Use the `id` from `auth.users` as the `id` for this `public.users` table.
```

**SQL for `user_progress` table:**
```sql
CREATE TABLE public.user_progress (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL,
    letters_progress INTEGER DEFAULT 0,
    three_letter_words_progress INTEGER DEFAULT 0,
    four_letter_words_progress INTEGER DEFAULT 0,
    five_letter_words_progress INTEGER DEFAULT 0,
    sentences_progress INTEGER DEFAULT 0,
    total_stickers INTEGER DEFAULT 0,
    current_streak INTEGER DEFAULT 0,
    last_played_date DATE,
    updated_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE
);
```

### Using Table Editor

1.  Navigate to the **Table Editor** in the Supabase dashboard (icon that looks like a spreadsheet).
2.  Click **New table**.
3.  Enter `users` as the **Table name**.
4.  **Disable Row Level Security (RLS)** for now. We will enable it later.
5.  Define the columns:
    *   `id`: Type `uuid`, Is Primary. Default: `uuid_generate_v4()`. **Important**: As per subtask, this should reference `auth.users(id)`. If using the table editor, you'd set this as primary key. Then, after table creation, go to its properties to add the foreign key constraint to `auth.users(id)`. For this, `id` should not have a default like `uuid_generate_v4()` but should take the value from `auth.users.id`. This makes manual setup via table editor tricky for this specific requirement. It's easier to run the SQL.
    *   `email`: Type `text`, Is Unique.
    *   `name`: Type `text`, Is Nullable.
    *   `created_at`: Type `timestamptz`, Default: `now()`.
6.  Click **Save**.
7.  After creating the `users` table, if you didn't use the SQL for the foreign key: Select the `users` table, go to the "Relationships" tab or "Constraints" section, and add a foreign key from `users.id` to `auth.users.id` with `ON DELETE CASCADE`. (This assumes `auth.users` table is visible and accessible for such operations).

8.  Click **New table** again.
9.  Enter `user_progress` as the **Table name**.
10. **Disable Row Level Security (RLS)** for now.
11. Define the columns:
    *   `id`: Type `uuid`, Is Primary. Default: `uuid_generate_v4()`.
    *   `user_id`: Type `uuid`. Add a foreign key relationship to `public.users` table, column `id`, with `ON DELETE CASCADE`.
    *   `letters_progress`: Type `int4` (Integer), Default: `0`.
    *   `three_letter_words_progress`: Type `int4`, Default: `0`.
    *   `four_letter_words_progress`: Type `int4`, Default: `0`.
    *   `five_letter_words_progress`: Type `int4`, Default: `0`.
    *   `sentences_progress`: Type `int4`, Default: `0`.
    *   `total_stickers`: Type `int4`, Default: `0`.
    *   `current_streak`: Type `int4`, Default: `0`.
    *   `last_played_date`: Type `date`, Is Nullable.
    *   `updated_at`: Type `timestamptz`, Default: `now()`.
12. Click **Save**.

## 5. Enable Row Level Security (RLS) and Define Policies (Recommended)

RLS ensures users can only access and modify their own data.

1.  Go to **Authentication > Policies** in the Supabase dashboard.
2.  Find the `users` table and click **Enable RLS**.
3.  Create policies for the `users` table:
    *   **Policy Name:** "Users can view their own data."
    *   **Allowed operation:** `SELECT`
    *   **Target roles:** `authenticated`
    *   **USING expression:** `auth.uid() = id`
    *   **Policy Name:** "Users can update their own data."
    *   **Allowed operation:** `UPDATE`
    *   **Target roles:** `authenticated`
    *   **USING expression:** `auth.uid() = id`
    *   **WITH CHECK expression:** `auth.uid() = id`
    *   (Note: Insertion into `users` will be handled by NextAuth callbacks, possibly using service role or trusted context. If users need to insert their own record here after auth, a policy for INSERT would be `auth.uid() = id` for both expressions, assuming `id` is correctly supplied).

4.  Find the `user_progress` table and click **Enable RLS**.
5.  Create policies for the `user_progress` table:
    *   **Policy Name:** "Users can view their own progress."
    *   **Allowed operation:** `SELECT`
    *   **Target roles:** `authenticated`
    *   **USING expression:** `auth.uid() = user_id`
    *   **Policy Name:** "Users can create their own progress."
    *   **Allowed operation:** `INSERT`
    *   **Target roles:** `authenticated`
    *   **WITH CHECK expression:** `auth.uid() = user_id`
    *   **Policy Name:** "Users can update their own progress."
    *   **Allowed operation:** `UPDATE`
    *   **Target roles:** `authenticated`
    *   **USING expression:** `auth.uid() = user_id`
    *   **WITH CHECK expression:** `auth.uid() = user_id`
    *   **Policy Name:** "Users can delete their own progress." (Optional, if needed)
    *   **Allowed operation:** `DELETE`
    *   **Target roles:** `authenticated`
    *   **USING expression:** `auth.uid() = user_id`

**Important RLS Note:** The `auth.uid()` function in Supabase RLS policies refers to the ID of the authenticated user, derived from the JWT token submitted with the request. For this to work seamlessly with NextAuth:
*   The JWT issued by NextAuth and used in API requests to Supabase should contain a `sub` claim that matches the `id` in the `auth.users` table (which is then the `id` in your `public.users` table and `user_id` in `public.user_progress`).
*   If you are not using a Supabase adapter with NextAuth, you might need to customize the NextAuth JWT callback to ensure the token's `sub` claim is the Supabase `auth.users.id`. This is a complex topic.
*   If `auth.uid()` does not correctly resolve, RLS policies will not work as expected, and requests might be denied or allow unintended access. You might need to use the Supabase client with the `service_role` key for operations in NextAuth callbacks if RLS prevents writes, but this should be done carefully and only on the server side.

This setup provides a robust backend for your application. Remember to restart your Next.js development server after updating environment variables.
```Okay, I've created the `SUPABASE_SETUP_NOTES.md` file with detailed instructions.

There was a lot of internal monologue and self-correction regarding the `users` table definition, specifically the `id UUID PRIMARY KEY REFERENCES auth.users(id)` requirement. This setup has significant implications for how NextAuth interacts with Supabase, especially if a Supabase adapter for NextAuth isn't used. The notes include the SQL for the tables as requested and highlight the RLS considerations.

The provided SQL for `users` table is:
```sql
CREATE TABLE public.users (
    id UUID PRIMARY KEY, -- Must match auth.users.id
    email TEXT UNIQUE NOT NULL,
    name TEXT,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    CONSTRAINT fk_auth_user FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE
);
```
And for `user_progress`:
```sql
CREATE TABLE public.user_progress (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL,
    letters_progress INTEGER DEFAULT 0,
    three_letter_words_progress INTEGER DEFAULT 0,
    four_letter_words_progress INTEGER DEFAULT 0,
    five_letter_words_progress INTEGER DEFAULT 0,
    sentences_progress INTEGER DEFAULT 0,
    total_stickers INTEGER DEFAULT 0,
    current_streak INTEGER DEFAULT 0,
    last_played_date DATE,
    updated_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE
);
```
The notes also cover RLS setup.

Next, I will install the Supabase client library.
